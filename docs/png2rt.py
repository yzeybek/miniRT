#!/usr/bin/env python3
"""
PNG to RT converter for miniRT
Converts each pixel in a PNG image to a sphere in a .rt scene file

Usage: python3 png2rt.py <input.png> [output.rt] [options]

Options:
  --scale=N       Scale factor for the entire scene (default: 1.0)
  --spacing=N     Spacing between spheres (default: 1.0)
  --depth=N       Z-depth of the image plane (default: 50)
  --diameter=N    Diameter of each sphere (default: 0.8)
  --skip-alpha    Skip fully transparent pixels
  --skip-black    Skip black pixels (0,0,0)
  --threshold=N   Alpha threshold (0-255) to skip pixels (default: 0)
  --resize=WxH    Resize image before conversion (e.g., 32x32)

Requires: Pillow (pip3 install Pillow)
"""

import sys
import argparse
from pathlib import Path

try:
    from PIL import Image
except ImportError:
    print("Error: Pillow library not found!")
    print("Install with: pip3 install Pillow")
    sys.exit(1)


def parse_args():
    parser = argparse.ArgumentParser(
        description='Convert PNG image to miniRT scene file using spheres for each pixel'
    )
    parser.add_argument('input', help='Input PNG file')
    parser.add_argument('output', nargs='?', help='Output RT file (default: input.rt)')
    parser.add_argument('--scale', type=float, default=1.0,
                        help='Scale factor for the entire scene (default: 1.0)')
    parser.add_argument('--spacing', type=float, default=1.0,
                        help='Spacing between sphere centers (default: 1.0)')
    parser.add_argument('--depth', type=float, default=50.0,
                        help='Z-depth of the image plane (default: 50)')
    parser.add_argument('--diameter', type=float, default=0.8,
                        help='Diameter of each sphere (default: 0.8)')
    parser.add_argument('--cam-dist', type=float, default=-100.0,
                        help='Camera distance from origin (default: -100)')
    parser.add_argument('--ambient', type=float, default=0.3,
                        help='Ambient light ratio 0.0-1.0 (default: 0.3)')
    parser.add_argument('--light', type=float, default=0.8,
                        help='Light brightness 0.0-1.0 (default: 0.8)')
    parser.add_argument('--skip-alpha', action='store_true',
                        help='Skip fully transparent pixels')
    parser.add_argument('--skip-black', action='store_true',
                        help='Skip black pixels (0,0,0)')
    parser.add_argument('--threshold', type=int, default=0,
                        help='Alpha threshold (0-255) to skip pixels (default: 0)')
    parser.add_argument('--resize', type=str, default='',
                        help='Resize image before conversion (e.g., 32x32, 64x64)')

    return parser.parse_args()


def load_image(filepath, resize=None):
    """Load and optionally resize image, returning pixel data."""
    img = Image.open(filepath)

    # Resize if requested
    if resize:
        try:
            w, h = map(int, resize.lower().split('x'))
            img = img.resize((w, h), Image.Resampling.LANCZOS)
            print(f"Resized to: {w}x{h}")
        except ValueError:
            print(f"Warning: Invalid resize format '{resize}', ignoring")

    # Convert to RGBA to ensure we have alpha channel
    img = img.convert('RGBA')

    width, height = img.size
    pixels = list(img.getdata())

    return width, height, pixels


def generate_rt_file(output_path, width, height, pixels, args):
    """Generate the RT scene file."""

    # Calculate scene dimensions
    scene_width = width * args.spacing * args.scale
    scene_height = height * args.spacing * args.scale
    center_x = scene_width / 2
    center_y = scene_height / 2

    # Auto-adjust camera distance based on image size
    auto_cam_dist = -(args.depth + max(scene_width, scene_height) * 0.8)
    cam_dist = min(args.cam_dist, auto_cam_dist)

    # Count valid pixels first
    valid_count = 0
    for y in range(height):
        for x in range(width):
            r, g, b, a = pixels[y * width + x]
            if args.skip_alpha and a <= args.threshold:
                continue
            if args.skip_black and r == 0 and g == 0 and b == 0:
                continue
            valid_count += 1

    with open(output_path, 'w') as f:
        # Header comment
        f.write(f"# Generated by png2rt.py from {args.input}\n")
        f.write(f"# Image size: {width}x{height}, Total spheres: {valid_count}\n")
        f.write("\n")

        # Ambient light
        f.write(f"A\t{args.ambient}\t\t\t\t\t\t255,255,255\n")
        f.write("\n")

        # Camera
        f.write(f"C\t{center_x:.2f},{-center_y:.2f},{cam_dist:.2f}\t\t0,0,1\t\t70\n")
        f.write("\n")

        # Light source
        light_x = center_x
        light_y = -center_y + scene_height
        light_z = cam_dist + 20
        f.write(f"L\t{light_x:.2f},{light_y:.2f},{light_z:.2f}\t\t{args.light}\t\t255,255,255\n")
        f.write("\n")

        # Spheres
        f.write("# Spheres (one per pixel)\n")

        sphere_count = 0
        diameter = args.diameter * args.scale

        for y in range(height):
            for x in range(width):
                r, g, b, a = pixels[y * width + x]

                # Skip transparent pixels
                if args.skip_alpha and a <= args.threshold:
                    continue

                # Skip black pixels
                if args.skip_black and r == 0 and g == 0 and b == 0:
                    continue

                # Calculate sphere position
                sx = x * args.spacing * args.scale
                sy = -y * args.spacing * args.scale  # Flip Y axis
                sz = args.depth

                # Write sphere
                f.write(f"sp\t{sx:.3f},{sy:.3f},{sz:.3f}\t\t{diameter}\t\t{r},{g},{b}\n")
                sphere_count += 1

            # Progress indicator
            if (y + 1) % 20 == 0 or y == height - 1:
                percent = int((y + 1) / height * 100)
                print(f"Progress: {percent}% ({sphere_count} spheres)", end='\r')

        print()

    return sphere_count


def main():
    args = parse_args()

    # Check input file exists
    input_path = Path(args.input)
    if not input_path.exists():
        print(f"Error: Input file '{args.input}' does not exist")
        sys.exit(1)

    # Determine output file
    if args.output:
        output_path = Path(args.output)
    else:
        output_path = input_path.with_suffix('.rt')

    print(f"Converting '{args.input}' to '{output_path}'")
    print(f"Options: scale={args.scale}, spacing={args.spacing}, depth={args.depth}, diameter={args.diameter}")

    # Load image
    print("Loading image...")
    width, height, pixels = load_image(args.input, args.resize)
    print(f"Image size: {width}x{height}")

    # Generate RT file
    print("Generating RT file...")
    sphere_count = generate_rt_file(output_path, width, height, pixels, args)

    print(f"Done! Generated {sphere_count} spheres in '{output_path}'")


if __name__ == '__main__':
    main()
